* Systems Design
The design making process for a complex application

** Sample Interview Questions
- how would you build/design X?
- choose an application and walk through its components
- why do you think X framework was chosen over Y framework in this application?
- suppose we build system S, how would we handle X, Y, Z
- we want to design a service to perform X

*** Things to consider
- what are the use cases and who will use it?
  - casual users or big corporate clients?
- data storage
  - db style, data types, how long to store
- frontend
- collecting metrics
- exposing logs

**** Cool Terms
- job queue
- cache data layer
- load balancer
- microservices

**** White papers, Design Docs
- read them

* Computer Networking
** TCP/IP Model
- standard internet communication protocol
*** Layers
**** Link (a link)
- move data packets between Internet layer of 2 different hosts on same link
- usually physical connection
**** Internet (the internet)
- exchange data through routing/IP addressing
- IP, ICMP, IGMP
**** Transport (delivery)
- TCP, UDP
**** Application
- HTTP, FTP, SMTP, ...
** TCP (Transport)
*** Reliable
*** Session-based
- establish session through 3-way handshake
  - 3 messages
- all packets guaranteed to reach destination in correct order without corruption
- packet control to control data transfer rate
*** Workflow
1. A initiates with B
   a. they exchange packets in a pattern like a cool handshake
   b. they begin TCP
2. A sends packets to B with a sequence number and checksum for correct order + data integrity
3. B acknowledges receipt of packets
   a. If B does not acknowledge a packet, A resends
** UDP (Transport)
*** Speed
- no session
- sends data from A to B, no verification
  - hope for the best
- best for streaming
** HTTP (Application)
- send HTML
- client-response model

* API Design
** RPC
- call a function on a remote server
  + just like a regular function call
- action based APIs/execute processes remotely
- tight coupling
  + needs detailed documentation for usage
** REST
- resource based API
- stateless
- native caching
- idempotent
  - multiple identical requests is same as single request
- loose coupling

* Metrics
** Latency
*** Distance
**** CDN (Content Delivery Network)
- have many distributed CDN servers which store content closer to end users
*** Transport medium
- physical wires
  - optic fibers
*** Storage
- caching
- compress files
** Error Rates
*** RUM (Real User Monitoring)
- observe how users use app
** CPU Usage
- server speed
  - high traffic will slow down website
- optimize and clean extraneous data
** Memory Usage
- allocate more memory to VMs that need it

* Monolith vs. Microservices

** Low Coupling, High Cohesion
*** Coupling
- dependencies between different modules of an application
  + how much do they rely on one another
*** Cohesion
- how closely related are elements of a single module
** Monolith
- where the entire system has to be deployed at once
  + usually 1 server, 1 db, 1 file system
*** Pros
- easy to scale
- simple to develop/test
- easy to deploy
*** Cons
- low maintainability
  + high coupling
  + changes in one place will affect another place
- one error means entire system is down
- low design flexibility
  + stuck in 1 language
** Microservices
- distributed, decentralized
- each function is an independent application with own server/db
  + communicate through API calls
*** Pros
- independent deployment
- flexibility
  + each service is developed separately
- loose coupling
  + scale up individual services which require it
- fault-tolerant
  - error is isolated to its service
- parallel programming
*** Cons
- more time and money to develop
- latency introduced through API calls

* Caching Strategies
** Layers
- logical separation (organization) of code
- ex. UI layer, logic layer, DAL
** Tiers
- physical separation (deployment)
- n-tier architecture
  - each tier hosts a layer
- can host multiple layers in a single tier ex. combine logic layer and DAL as server tier

** 3-layer architectures
*** Presentation
- UI
*** Application
- logic, controllers
*** Data
- data storage and handling
** Caching
store data in kvp in fast volatile memory
*** HIT
- data in cache, unexpired
  - return cached data
*** MISS
- data not in cache
  - receive data from db, update cache, return data
** Pros
- fast data retrieval
- reduce query load/times to db
- can temporarily substitute for db if db unavailable
** Cons
- increased maintenance required
  + data security
- must keep data fresh
** Strategies
*** Aside
- default
- if cache has data, return to data else call db and update cache
- no guarantee of data consistency between db and cache
- first request is always a miss, must spend time to write

*** Read Through
- similar to above, but the application always requests from cache
  - cache is DAL and handles all data operations
- cache grabs data from DB and updates itself
+ the application only interacts with the cache and not the db

*** Write Through
- application writes data to cache instead of db
- cache then immediately writes to db
+ guaranteed data consistency
- increased write latency

*** Write Back
- application writes data to cache instead of db
- cache periodically writes to db
+ bear db downtimes
+ lesser load on db
- increased write latency
- cache failure results in complete data loss
